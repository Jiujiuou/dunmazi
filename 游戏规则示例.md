# ğŸ® æ¸¸æˆè§„åˆ™å®ç°ç¤ºä¾‹

æœ¬æ–‡æ¡£å±•ç¤ºå¦‚ä½•åœ¨ `src/utils/gameLogic.js` ä¸­å®ç°ä¸åŒçš„æ‰‘å…‹ç‰Œæ¸¸æˆè§„åˆ™ã€‚

---

## ğŸ“– ç›®å½•

1. [ç®€å•æ¯”å¤§å°](#1-ç®€å•æ¯”å¤§å°)
2. [UNO é£æ ¼æ¸¸æˆ](#2-uno-é£æ ¼æ¸¸æˆ)
3. [æ–—åœ°ä¸»ï¼ˆåŸºç¡€ç‰ˆï¼‰](#3-æ–—åœ°ä¸»åŸºç¡€ç‰ˆ)
4. [å¾·å·æ‰‘å…‹ï¼ˆç®€åŒ–ç‰ˆï¼‰](#4-å¾·å·æ‰‘å…‹ç®€åŒ–ç‰ˆ)

---

## 1. ç®€å•æ¯”å¤§å°

### æ¸¸æˆè§„åˆ™

- 2-4 äººæ¸¸æˆ
- æ¯äººå‘ 5 å¼ ç‰Œ
- è½®æµå‡ºä¸€å¼ ç‰Œï¼Œç‰Œé¢æœ€å¤§çš„è·èƒœ
- å…ˆå‡ºå®Œç‰Œçš„ç©å®¶è·èƒœ

### å®ç°ä»£ç 

```javascript
// src/utils/gameLogic.js

export const GAME_CONFIG = {
  MIN_PLAYERS: 2,
  MAX_PLAYERS: 4,
  CARDS_PER_PLAYER: 5,
  USE_JOKERS: false,
};

export class PokerGame {
  static initGameState(playerCount) {
    return {
      round: 0,
      phase: "dealing",
      currentPlayer: 0,
      playerCount: playerCount,
      roundWinner: null,
      lastCards: [], // æœ¬è½®æ‰€æœ‰ç©å®¶å‡ºçš„ç‰Œ
    };
  }

  static dealToPlayers(deck, players, cardsPerPlayer = 5) {
    let remainingDeck = [...deck];
    const playerHands = [];

    players.forEach(() => {
      const { dealt, remaining } = dealCards(remainingDeck, cardsPerPlayer);
      playerHands.push(dealt);
      remainingDeck = remaining;
    });

    return { playerHands, remainingDeck };
  }

  static canPlayCard(player, card, gameState) {
    // å¿…é¡»è½®åˆ°è¯¥ç©å®¶
    const playerIndex = gameState.currentPlayer;
    return true; // ä»»ä½•æ—¶å€™éƒ½å¯ä»¥å‡ºç‰Œ
  }

  static playCard(player, card, gameState) {
    const newHand = player.hand.filter(
      (c) => !(c.suit === card.suit && c.rank === card.rank)
    );

    const newLastCards = [
      ...gameState.lastCards,
      {
        playerId: player.id,
        card,
      },
    ];

    // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºç‰Œäº†ï¼Œåˆ¤æ–­æœ¬è½®è·èƒœè€…
    let newGameState = { ...gameState, lastCards: newLastCards };

    if (newLastCards.length === gameState.playerCount) {
      // æ‰¾å‡ºæœ€å¤§çš„ç‰Œ
      const winner = newLastCards.reduce((max, current) => {
        return compareCards(current.card, max.card) > 0 ? current : max;
      });

      newGameState = {
        ...newGameState,
        roundWinner: winner.playerId,
        round: gameState.round + 1,
        lastCards: [],
        currentPlayer: 0,
      };
    } else {
      newGameState.currentPlayer =
        (gameState.currentPlayer + 1) % gameState.playerCount;
    }

    return { newHand, newGameState };
  }

  static checkGameEnd(players, gameState) {
    // ç¬¬ä¸€ä¸ªå‡ºå®Œç‰Œçš„ç©å®¶è·èƒœ
    const winner = players.find((p) => p.hand.length === 0);

    if (winner) {
      return {
        winnerId: winner.id,
        winnerNickname: winner.nickname,
        reason: "cards_finished",
      };
    }

    return null;
  }
}
```

---

## 2. UNO é£æ ¼æ¸¸æˆ

### æ¸¸æˆè§„åˆ™

- 2-4 äººæ¸¸æˆ
- æ¯äººå‘ 7 å¼ ç‰Œ
- å‡ºçš„ç‰Œå¿…é¡»å’Œä¸Šä¸€å¼ ç‰Œé¢œè‰²æˆ–æ•°å­—ç›¸åŒ
- å…ˆå‡ºå®Œç‰Œçš„ç©å®¶è·èƒœ

### å®ç°ä»£ç 

```javascript
export const GAME_CONFIG = {
  MIN_PLAYERS: 2,
  MAX_PLAYERS: 4,
  CARDS_PER_PLAYER: 7,
  USE_JOKERS: false,
};

export class PokerGame {
  static initGameState(playerCount) {
    return {
      phase: "playing",
      currentPlayer: 0,
      playerCount: playerCount,
      lastPlayedCard: null, // ä¸Šä¸€å¼ å‡ºçš„ç‰Œ
      direction: 1, // å‡ºç‰Œæ–¹å‘ï¼š1æ­£å‘ï¼Œ-1åå‘
    };
  }

  static dealToPlayers(deck, players, cardsPerPlayer = 7) {
    // ... åŒä¸Š
  }

  static canPlayCard(player, card, gameState) {
    const { lastPlayedCard } = gameState;

    // ç¬¬ä¸€å¼ ç‰Œå¯ä»¥éšæ„å‡º
    if (!lastPlayedCard) return true;

    // å¿…é¡»èŠ±è‰²ç›¸åŒæˆ–ç‰Œé¢ç›¸åŒ
    return (
      card.suit === lastPlayedCard.suit || card.rank === lastPlayedCard.rank
    );
  }

  static playCard(player, card, gameState) {
    const newHand = player.hand.filter(
      (c) => !(c.suit === card.suit && c.rank === card.rank)
    );

    const newGameState = {
      ...gameState,
      lastPlayedCard: card,
      currentPlayer:
        (gameState.currentPlayer +
          gameState.direction +
          gameState.playerCount) %
        gameState.playerCount,
      lastAction: {
        playerId: player.id,
        card,
        timestamp: Date.now(),
      },
    };

    return { newHand, newGameState };
  }

  static checkGameEnd(players, gameState) {
    const winner = players.find((p) => p.hand.length === 0);

    if (winner) {
      return {
        winnerId: winner.id,
        winnerNickname: winner.nickname,
        reason: "cards_finished",
      };
    }

    return null;
  }
}
```

---

## 3. æ–—åœ°ä¸»ï¼ˆåŸºç¡€ç‰ˆï¼‰

### æ¸¸æˆè§„åˆ™

- 3 äººæ¸¸æˆ
- æ¯äºº 17 å¼ ç‰Œï¼Œ3 å¼ åº•ç‰Œ
- å«åœ°ä¸»é˜¶æ®µ â†’ å‡ºç‰Œé˜¶æ®µ
- åœ°ä¸»å…ˆå‡ºå®Œç‰Œåˆ™åœ°ä¸»èµ¢ï¼Œå¦åˆ™å†œæ°‘èµ¢

### å®ç°ä»£ç 

```javascript
export const GAME_CONFIG = {
  MIN_PLAYERS: 3,
  MAX_PLAYERS: 3,
  CARDS_PER_PLAYER: 17,
  USE_JOKERS: true,
  BOTTOM_CARDS: 3,
};

export class PokerGame {
  static initGameState(playerCount) {
    return {
      phase: "bidding", // bidding(å«åœ°ä¸»), playing(æ¸¸æˆä¸­)
      currentPlayer: 0,
      playerCount: 3,
      landlordId: null, // åœ°ä¸»ID
      currentBid: 0, // å½“å‰å«åˆ†ï¼ˆ1-3ï¼‰
      bottomCards: [], // åº•ç‰Œ
      lastPlay: null, // ä¸Šä¸€æ¬¡å‡ºç‰Œ
      passCount: 0, // è¿ç»­è¿‡ç‰Œæ¬¡æ•°
    };
  }

  static dealToPlayers(deck, players, cardsPerPlayer = 17) {
    let remainingDeck = [...deck];
    const playerHands = [];

    // å‘17å¼ ç»™æ¯äºº
    players.forEach(() => {
      const { dealt, remaining } = dealCards(remainingDeck, cardsPerPlayer);
      playerHands.push(dealt);
      remainingDeck = remaining;
    });

    // å‰©ä½™3å¼ ä½œä¸ºåº•ç‰Œ
    const bottomCards = remainingDeck.slice(0, 3);

    return { playerHands, remainingDeck: [], bottomCards };
  }

  static bid(playerId, bidAmount, gameState) {
    // bidAmount: 1-3åˆ†ï¼Œæˆ– 0 è¡¨ç¤ºä¸å«
    if (bidAmount > gameState.currentBid) {
      return {
        ...gameState,
        currentBid: bidAmount,
        landlordId: playerId,
      };
    }

    // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç©å®¶
    const nextPlayer = (gameState.currentPlayer + 1) % 3;
    return {
      ...gameState,
      currentPlayer: nextPlayer,
    };
  }

  static startPlaying(gameState, bottomCards) {
    // å«åœ°ä¸»é˜¶æ®µç»“æŸï¼Œå¼€å§‹æ¸¸æˆ
    return {
      ...gameState,
      phase: "playing",
      currentPlayer: gameState.landlordId, // åœ°ä¸»å…ˆå‡º
    };
  }

  static canPlayCard(cards, gameState) {
    // ç®€åŒ–ç‰ˆï¼šåªæ£€æŸ¥æ˜¯å¦è½®åˆ°è¯¥ç©å®¶
    // å®Œæ•´ç‰ˆéœ€è¦æ£€æŸ¥ç‰Œå‹ï¼ˆå•ç‰Œã€å¯¹å­ã€é¡ºå­ç­‰ï¼‰
    return true;
  }

  static playCard(player, cards, gameState) {
    // cards å¯ä»¥æ˜¯å•å¼ æˆ–å¤šå¼ 
    const newHand = player.hand.filter(
      (c) => !cards.some((card) => card.suit === c.suit && card.rank === c.rank)
    );

    const newGameState = {
      ...gameState,
      lastPlay: {
        playerId: player.id,
        cards: cards,
      },
      passCount: 0,
      currentPlayer: (gameState.currentPlayer + 1) % 3,
    };

    return { newHand, newGameState };
  }

  static pass(gameState) {
    // ç©å®¶é€‰æ‹©"è¿‡"
    return {
      ...gameState,
      passCount: gameState.passCount + 1,
      currentPlayer: (gameState.currentPlayer + 1) % 3,
    };
  }

  static checkGameEnd(players, gameState) {
    // æ‰¾åˆ°åœ°ä¸»
    const landlord = players.find((p) => p.id === gameState.landlordId);

    if (landlord && landlord.hand.length === 0) {
      return {
        winnerId: landlord.id,
        winnerNickname: landlord.nickname,
        winnerRole: "landlord",
        reason: "landlord_win",
      };
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å†œæ°‘å‡ºå®Œç‰Œ
    const farmer = players.find(
      (p) => p.id !== gameState.landlordId && p.hand.length === 0
    );

    if (farmer) {
      return {
        winnerId: farmer.id,
        winnerNickname: farmer.nickname,
        winnerRole: "farmer",
        reason: "farmer_win",
      };
    }

    return null;
  }

  // å·¥å…·å‡½æ•°ï¼šåˆ¤æ–­ç‰Œå‹
  static getCardType(cards) {
    if (cards.length === 1) return "single"; // å•ç‰Œ
    if (cards.length === 2) return "pair"; // å¯¹å­
    if (cards.length === 3) return "triple"; // ä¸‰å¼ 
    // ... æ›´å¤šç‰Œå‹åˆ¤æ–­
    return "invalid";
  }

  // å·¥å…·å‡½æ•°ï¼šæ¯”è¾ƒç‰Œå‹å¤§å°
  static compareCardSets(cards1, cards2) {
    // å®ç°ç‰Œå‹æ¯”è¾ƒé€»è¾‘
    return 0;
  }
}
```

---

## 4. å¾·å·æ‰‘å…‹ï¼ˆç®€åŒ–ç‰ˆï¼‰

### æ¸¸æˆè§„åˆ™

- 2-6 äººæ¸¸æˆ
- æ¯äºº 2 å¼ åº•ç‰Œ
- 5 å¼ å…¬å…±ç‰Œ
- æ¯”è¾ƒç‰Œå‹å¤§å°

### å®ç°ä»£ç 

```javascript
export const GAME_CONFIG = {
  MIN_PLAYERS: 2,
  MAX_PLAYERS: 6,
  CARDS_PER_PLAYER: 2, // åº•ç‰Œ
  USE_JOKERS: false,
};

export class PokerGame {
  static initGameState(playerCount) {
    return {
      phase: "preflop", // preflop, flop, turn, river, showdown
      currentPlayer: 0,
      playerCount: playerCount,
      pot: 0, // å¥–æ± 
      communityCards: [], // å…¬å…±ç‰Œï¼ˆæœ€å¤š5å¼ ï¼‰
      currentBet: 0, // å½“å‰è½®æœ€å¤§ä¸‹æ³¨
      dealerPosition: 0, // åº„å®¶ä½ç½®
    };
  }

  static dealToPlayers(deck, players, cardsPerPlayer = 2) {
    let remainingDeck = [...deck];
    const playerHands = [];

    // æ¯äººå‘2å¼ åº•ç‰Œ
    players.forEach(() => {
      const { dealt, remaining } = dealCards(remainingDeck, cardsPerPlayer);
      playerHands.push(dealt);
      remainingDeck = remaining;
    });

    return { playerHands, remainingDeck };
  }

  static dealCommunityCards(deck, count, gameState) {
    // å‘å…¬å…±ç‰Œ
    const newCommunityCards = [
      ...gameState.communityCards,
      ...deck.slice(0, count),
    ];
    const remainingDeck = deck.slice(count);

    return { newCommunityCards, remainingDeck };
  }

  static nextPhase(gameState, newCommunityCards) {
    const phases = ["preflop", "flop", "turn", "river", "showdown"];
    const currentIndex = phases.indexOf(gameState.phase);

    return {
      ...gameState,
      phase: phases[currentIndex + 1],
      communityCards: newCommunityCards,
      currentBet: 0,
      currentPlayer: gameState.dealerPosition,
    };
  }

  static bet(player, amount, gameState) {
    // ç©å®¶ä¸‹æ³¨
    return {
      ...gameState,
      pot: gameState.pot + amount,
      currentBet: Math.max(gameState.currentBet, amount),
    };
  }

  static fold(player, gameState) {
    // ç©å®¶å¼ƒç‰Œ
    return {
      ...gameState,
      // æ ‡è®°ç©å®¶å·²å¼ƒç‰Œ
    };
  }

  static checkGameEnd(players, gameState) {
    if (gameState.phase !== "showdown") return null;

    // æ¯”è¾ƒæ‰€æœ‰ç©å®¶çš„ç‰Œå‹
    const winner = players.reduce((best, current) => {
      const bestHand = this.evaluateHand([
        ...best.hand,
        ...gameState.communityCards,
      ]);
      const currentHand = this.evaluateHand([
        ...current.hand,
        ...gameState.communityCards,
      ]);
      return currentHand > bestHand ? current : best;
    });

    return {
      winnerId: winner.id,
      winnerNickname: winner.nickname,
      reason: "best_hand",
      pot: gameState.pot,
    };
  }

  static evaluateHand(cards) {
    // è¯„ä¼°ç‰Œå‹ï¼ˆçš‡å®¶åŒèŠ±é¡ºã€åŒèŠ±é¡ºã€å››æ¡ç­‰ï¼‰
    // è¿”å›ç‰Œå‹å€¼ï¼Œæ•°å­—è¶Šå¤§è¶Šå¥½
    // è¿™é‡Œéœ€è¦å®ç°å¾·å·æ‰‘å…‹çš„ç‰Œå‹åˆ¤æ–­é€»è¾‘
    return 0;
  }
}
```

---

## ğŸ¯ å¦‚ä½•é€‰æ‹©å’Œä½¿ç”¨

### 1. é€‰æ‹©ä¸€ä¸ªæ¸¸æˆè§„åˆ™

ä»ä¸Šé¢é€‰æ‹©ä¸€ä¸ªä½ æƒ³å®ç°çš„æ¸¸æˆï¼Œæˆ–è€…è‡ªå·±è®¾è®¡è§„åˆ™ã€‚

### 2. å¤åˆ¶ä»£ç åˆ°é¡¹ç›®

å°†å¯¹åº”çš„ä»£ç å¤åˆ¶åˆ° `src/utils/gameLogic.js`

### 3. è°ƒæ•´é…ç½®

æ ¹æ®éœ€è¦ä¿®æ”¹ `GAME_CONFIG`ï¼š

```javascript
export const GAME_CONFIG = {
  MIN_PLAYERS: 2, // æœ€å°‘ç©å®¶
  MAX_PLAYERS: 4, // æœ€å¤šç©å®¶
  CARDS_PER_PLAYER: 5, // å‘ç‰Œæ•°é‡
  USE_JOKERS: false, // æ˜¯å¦ä½¿ç”¨å¤§å°ç‹
  // å¯ä»¥æ·»åŠ æ›´å¤šè‡ªå®šä¹‰é…ç½®
};
```

### 4. æµ‹è¯•æ¸¸æˆ

```bash
npm run dev
```

è®¿é—® http://localhost:5173/poker å¼€å§‹æµ‹è¯•

### 5. æ ¹æ®éœ€è¦è°ƒæ•´ UI

å¦‚æœæ¸¸æˆè§„åˆ™éœ€è¦ç‰¹æ®Šçš„ UIï¼ˆå¦‚æ˜¾ç¤ºå…¬å…±ç‰Œã€æ˜¾ç¤ºç­¹ç ç­‰ï¼‰ï¼Œä¿®æ”¹ `src/components/GameRoom/index.jsx`

---

## ğŸ’¡ å¼€å‘æŠ€å·§

### 1. å…ˆå®ç°ç®€å•ç‰ˆæœ¬

ä¸è¦ä¸€å¼€å§‹å°±è¿½æ±‚å®Œç¾ï¼Œå…ˆå®ç°åŸºç¡€åŠŸèƒ½ï¼š

- âœ… èƒ½åˆ›å»ºæˆ¿é—´
- âœ… èƒ½åŠ å…¥æˆ¿é—´
- âœ… èƒ½å‘ç‰Œ
- âœ… èƒ½å‡ºç‰Œ
- âœ… èƒ½åˆ¤æ–­è·èƒœ

### 2. é€æ­¥æ·»åŠ è§„åˆ™

ä»ç®€å•è§„åˆ™å¼€å§‹ï¼š

```javascript
// ç¬¬ä¸€ç‰ˆï¼šä»»ä½•æ—¶å€™éƒ½èƒ½å‡ºç‰Œ
static canPlayCard() {
  return true
}

// ç¬¬äºŒç‰ˆï¼šæ·»åŠ åŸºç¡€è§„åˆ™
static canPlayCard(player, card, gameState) {
  return card.suit === gameState.lastCard.suit
}

// ç¬¬ä¸‰ç‰ˆï¼šæ·»åŠ å¤æ‚è§„åˆ™
static canPlayCard(player, card, gameState) {
  // æ£€æŸ¥ç‰Œå‹ã€èŠ±è‰²ã€æ•°å­—ç­‰
}
```

### 3. ä½¿ç”¨æ§åˆ¶å°è°ƒè¯•

åœ¨å…³é”®ä½ç½®æ·»åŠ æ—¥å¿—ï¼š

```javascript
console.log("å½“å‰æ¸¸æˆçŠ¶æ€:", gameState);
console.log("ç©å®¶æ‰‹ç‰Œ:", player.hand);
console.log("å‡ºç‰ŒéªŒè¯ç»“æœ:", canPlay);
```

### 4. åœ¨ Supabase æŸ¥çœ‹æ•°æ®

- è¿›å…¥ Supabase Dashboard
- ç‚¹å‡» Table Editor
- æŸ¥çœ‹ `games`ã€`players` è¡¨çš„æ•°æ®
- ç¡®è®¤æ•°æ®æ˜¯å¦æ­£ç¡®å­˜å‚¨

---

## ğŸš€ è¿›é˜¶åŠŸèƒ½

å½“åŸºç¡€åŠŸèƒ½å®Œæˆåï¼Œå¯ä»¥æ·»åŠ ï¼š

1. **åŠ¨ç”»æ•ˆæœ**

   - å‡ºç‰ŒåŠ¨ç”»
   - ç¿»ç‰ŒåŠ¨ç”»
   - è·èƒœç‰¹æ•ˆ

2. **éŸ³æ•ˆ**

   - å‘ç‰Œå£°
   - å‡ºç‰Œå£°
   - è·èƒœéŸ³ä¹

3. **èŠå¤©åŠŸèƒ½**

   - å®æ—¶èŠå¤©
   - è¡¨æƒ…åŒ…

4. **æˆ˜ç»©ç»Ÿè®¡**

   - èƒœç‡
   - å†å²è®°å½•

5. **æˆ¿é—´è®¾ç½®**
   - æˆ¿é—´å¯†ç 
   - è§‚æˆ˜æ¨¡å¼
   - è¸¢äººåŠŸèƒ½

---

## ğŸ“š å‚è€ƒèµ„æº

- æ‰‘å…‹ç‰Œæ¸¸æˆè§„åˆ™å¤§å…¨ï¼šhttps://zh.wikipedia.org/wiki/æ‰‘å…‹
- ç‰Œå‹åˆ¤æ–­ç®—æ³•ï¼šæœç´¢ "poker hand evaluator"
- Supabase å®æ—¶åŠŸèƒ½ï¼šhttps://supabase.com/docs/guides/realtime

---

ç¥ä½ å¼€å‘é¡ºåˆ©ï¼é€‰æ‹©ä¸€ä¸ªæ¸¸æˆï¼Œå¼€å§‹å®ç°å§ï¼ğŸ®
