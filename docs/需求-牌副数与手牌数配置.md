# 需求：牌副数与手牌数配置 — 实施方案

## 一、需求简述

- **Lobby 新增两个配置项**
  1. 游戏默认 **1 副牌** 或 **2 副牌**
  2. 玩家手牌默认 **5 张** 或 **6 张**

- **规则约定**
  - 手牌 5 张：起始玩家发 **6** 张，公共区满 **5** 张可自由交换
  - 手牌 6 张：起始玩家发 **7** 张，公共区满 **6** 张可自由交换  
  - 即：**公共区最大容量 = 手牌数**，**起始玩家手牌数 = 手牌数 + 1**

---

## 二、数据库变更

### 2.1 在 Supabase SQL Editor 中执行

```sql
-- =====================================================
-- 牌副数 / 手牌数配置：为 games 表新增列
-- 执行前请确认当前 games 表存在且无同名列
-- =====================================================

-- 1. 新增牌副数（1 或 2）
ALTER TABLE games
  ADD COLUMN IF NOT EXISTS deck_count smallint NOT NULL DEFAULT 1
  CHECK (deck_count IN (1, 2));

-- 2. 新增手牌数（5 或 6），同时决定公共区容量
ALTER TABLE games
  ADD COLUMN IF NOT EXISTS hand_size smallint NOT NULL DEFAULT 5
  CHECK (hand_size IN (5, 6));

-- 3. 为已有数据设置默认值（若列已存在且部分行为 NULL 时可执行）
-- UPDATE games SET deck_count = 1 WHERE deck_count IS NULL;
-- UPDATE games SET hand_size = 5 WHERE hand_size IS NULL;

-- 4. 可选：添加注释便于维护
COMMENT ON COLUMN games.deck_count IS '牌副数：1 或 2，创建房间时设定';
COMMENT ON COLUMN games.hand_size IS '每人手牌数：5 或 6，公共区容量与此一致，起始玩家发 hand_size+1 张';
```

### 2.2 说明

- **deck_count**：创建房间时写入，开局与下一局发牌时用其生成牌堆（1 副 54 张或 2 副 108 张）。
- **hand_size**：创建房间时写入；逻辑上 **公共区最大容量 = hand_size**，起始玩家发 **hand_size + 1** 张，其余玩家 **hand_size** 张。
- 现有行会因 `DEFAULT 1` / `DEFAULT 5` 自动填值，无需单独 backfill（除非你之前已加过列且允许 NULL）。

---

## 三、前端修改范围总览

| 层级 | 文件 | 修改要点 |
|------|------|----------|
| 常量 | `src/constants/gameConfig.js` | 新增 `DECK_COUNT_OPTIONS`、`HAND_SIZE_OPTIONS`（Lobby 用）；保留 `CARDS_PER_PLAYER`、`PUBLIC_ZONE_MAX` 作默认/兼容 |
| 大厅 | `src/components/Lobby.jsx` | 创建房间表单增加「牌副数」「手牌数」选项；state 与提交时传 `deckCount`、`handSize`；`createGame(nickname, totalRounds, targetScore, deckCount, handSize)` |
| Store | `src/stores/gameStore.js` | 见下节 |
| 牌堆 | `src/utils/cardUtils.js` | 支持多副牌：`createDeck(count = 1)` 或 `createDecks(n)`，多副时每张牌 `id` 唯一 |
| 牌型 | `src/utils/handEvaluation.js` | `checkFlush(hand, handSize)`，`canKnock` / `evaluateHand` / `getPlayerStatus` 等传入本局 `handSize`，同花/扣牌按手牌张数判定 |
| 游戏间 | `src/components/GameRoom.jsx` | 公共区容量、自由交换条件等从 `game.hand_size` 推导（publicZoneMax = game.hand_size），不再写死 `GAME_CONFIG.PUBLIC_ZONE_MAX` |
| 公共区 | `src/components/PlayArea.jsx` | 公共区卡槽数由 props 传入（= `game.hand_size`），不再写死 5 |
| 文档 | `docs/游戏规则.md`、`docs/架构说明.md`、`docs/实现进度.md` | 补充或调整「可配置手牌数 / 牌副数」说明 |

以下仅 **gameStore** 展开为具体改动点，其余文件按上表 + 下文「逻辑约定」实现即可。

---

## 四、gameStore.js 具体改动点

### 4.1 createGame

- **签名**：`createGame(nickname, totalRounds, targetScore, deckCount = 1, handSize = 5)`
- **insert games**：在现有字段基础上增加 `deck_count: deckCount`、`hand_size: handSize`。

### 4.2 startGame（开局发牌）

- 从 **game** 读取：`const deckCount = game.deck_count ?? 1`，`const handSize = game.hand_size ?? 5`。
- **牌堆**：用 `deckCount` 生成多副牌（调用 `cardUtils` 新接口），洗牌后作为本局 `deck`。
- **发牌**：
  - 起始玩家：`handSize + 1` 张
  - 其余玩家：`handSize` 张
- **game_state**：写入时不必再存 `rules`，后续所有需要「公共区上限」的地方统一用 **game.hand_size**（即 publicZoneMax = game.hand_size）。

### 4.3 startNextRound（下一局）

- 同样从当前 **game** 读 `game.deck_count`、`game.hand_size`，发牌规则与 startGame 一致（起始 handSize+1，其余 handSize），牌堆用 deckCount 副。

### 4.4 所有使用「公共区上限」的地方

- 将 **GAME_CONFIG.PUBLIC_ZONE_MAX** 改为从当前 **game** 取：**publicZoneMax = game.hand_size**（若 game 从 get() 取得，注意在异步回调中用最新的 game）。
- 涉及方法示例：
  - **drawCard**：`publicZone.length >= publicZoneMax` 则不可摸牌（或现有等价判断）。
  - **playCard**：出牌后手牌数须为 **handSize**（首回合后为 handSize，摸牌打牌后也为 handSize）；若当前有「必须 5 张」的校验，改为 `game.hand_size`。
  - **forceSwap**：N 为 publicZone.length，且 `N === 0 || N >= publicZoneMax` 时不可强制交换；即 N 在 1～publicZoneMax-1 之间才可执行。
  - **selectiveSwap**：公共区须 `publicZone.length === publicZoneMax`；可选张数 M 为 1～publicZoneMax，校验与提示中的上限改为 publicZoneMax。
  - **clearPublicZone**：公共区须 `publicZone.length === publicZoneMax` 才能清场。
- **playCardAfterClear**（清场后出 1 张）：逻辑不变，仅保证手牌数校验用 `game.hand_size`。

### 4.5 手牌数校验

- 凡校验「手牌应为 5 张」的地方，改为「手牌应为 game.hand_size 张」（首回合结束时起始玩家为 handSize，其余时刻均为 handSize）。

---

## 五、cardUtils.js：多副牌

- 现有 `createDeck()` 返回 54 张，`id` 为 `suit_rank`，两副牌会重复。
- **方案**：新增 `createDecks(count = 1)`，或为 `createDeck(count)`：
  - 循环 `count` 次，每次生成一副 54 张；
  - 每张牌 `id` 唯一，例如 `id: \`${suit}_${rank}_${deckIndex}_${cardIndex}\`` 或 `crypto.randomUUID()`。
- 发牌、洗牌接口不变，仍对「一整副大牌堆」操作。

---

## 六、handEvaluation.js：手牌张数参数化

- **checkFlush(hand, handSize = 5)**：将 `hand.length !== 5` 改为 `hand.length !== handSize`；其余同花逻辑不变。
- **canKnock(hand, targetScore, handSize = 5)**：内部调用 `checkFlush(hand, handSize)`；若当前签名只有 `(hand, targetScore)`，改为传入 `handSize`（从 game.hand_size 来）。
- **evaluateHand** / **getPlayerStatus**：若依赖 checkFlush/canKnock，增加参数 **handSize**，并向下传递。
- 所有调用处（如 GameRoom、gameStore 的扣牌校验）从 **game.hand_size** 传入 handSize。

---

## 七、GameRoom.jsx 与 PlayArea.jsx

- **GameRoom**：
  - 定义 `const publicZoneMax = game?.hand_size ?? GAME_CONFIG.PUBLIC_ZONE_MAX`（兼容旧数据或无 hand_size 时用默认 5）。
  - 所有 `GAME_CONFIG.PUBLIC_ZONE_MAX` 改为 `publicZoneMax`（摸牌、强制交换、自由交换、清场条件及提示文案中的「5 张」改为 `${publicZoneMax} 张`）。
- **PlayArea**：
  - 公共区卡槽数改为由 props 传入，例如 `maxSlots={game?.hand_size ?? 5}`，组件内用 `maxSlots` 替代写死的 5。

---

## 八、逻辑与数据流小结

1. **创建房间**：Lobby 选择牌副数、手牌数 → `createGame(..., deckCount, handSize)` → 写入 **games.deck_count**、**games.hand_size**。
2. **开局 / 下一局**：从 **game.deck_count**、**game.hand_size** 读；牌堆 = 合并 deckCount 副牌；发牌：起始 handSize+1，其余 handSize；公共区容量 = handSize。
3. **对局中**：所有与「公共区满」「手牌张数」相关的判断与提示，统一使用 **game.hand_size**（及由它派生的 publicZoneMax）。
4. **牌型与扣牌**：handEvaluation 系列函数增加 **handSize** 参数，与 **game.hand_size** 一致。

按上述执行 SQL 并完成前端修改后，即可在不改表结构的前提下支持「1/2 副牌」与「5/6 张手牌」两种配置，且与现有 target_score、total_rounds 等列风格一致。
